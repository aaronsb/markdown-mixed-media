#!/usr/bin/env node
/**
 * Generate version information from git or package.json
 * Creates src/version.ts with version info
 *
 * Priority:
 * 1. Git tags (for development builds)
 * 2. package.json version (for tarball builds without git)
 */

import { execSync } from 'child_process';
import { writeFileSync, readFileSync, existsSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const projectRoot = join(__dirname, '..');
const outputPath = join(projectRoot, 'src', 'version.ts');

function getPackageVersion() {
  try {
    const packageJson = JSON.parse(readFileSync(join(projectRoot, 'package.json'), 'utf-8'));
    return packageJson.version ? `v${packageJson.version}` : 'unknown';
  } catch (e) {
    return 'unknown';
  }
}

function hasGitRepo() {
  // Check if .git exists in project root (not a parent directory)
  return existsSync(join(projectRoot, '.git'));
}

function getGitInfo() {
  // If no .git in project root, use package.json (tarball build)
  if (!hasGitRepo()) {
    return {
      hash: 'release',
      tag: getPackageVersion(),
      branch: 'release',
      dirty: false
    };
  }

  try {
    // Get current commit hash (short)
    const gitHash = execSync('git rev-parse --short HEAD', {
      cwd: projectRoot,
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe']
    }).trim();

    // Get current tag (if any)
    let gitTag = '';
    try {
      gitTag = execSync('git describe --tags --exact-match 2>/dev/null', {
        cwd: projectRoot,
        encoding: 'utf-8',
        stdio: ['pipe', 'pipe', 'pipe']
      }).trim();
    } catch (e) {
      // No exact tag match, try to get the latest tag
      try {
        gitTag = execSync('git describe --tags --abbrev=0 2>/dev/null', {
          cwd: projectRoot,
          encoding: 'utf-8',
          stdio: ['pipe', 'pipe', 'pipe']
        }).trim();
      } catch (e2) {
        // Fall back to package.json version
        gitTag = getPackageVersion();
      }
    }

    // Get branch name
    const gitBranch = execSync('git rev-parse --abbrev-ref HEAD', {
      cwd: projectRoot,
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe']
    }).trim();

    // Check if working directory is dirty
    const gitDirty = execSync('git status --porcelain', {
      cwd: projectRoot,
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe']
    }).trim() !== '';

    return {
      hash: gitHash,
      tag: gitTag,
      branch: gitBranch,
      dirty: gitDirty
    };
  } catch (error) {
    // Git not available (e.g., tarball build) - use package.json
    return {
      hash: 'release',
      tag: getPackageVersion(),
      branch: 'release',
      dirty: false
    };
  }
}

function generateVersionFile() {
  const gitInfo = getGitInfo();

  const content = `// This file is auto-generated by scripts/generate-version.js
// Do not edit manually

export const VERSION_INFO = {
  hash: '${gitInfo.hash}',
  tag: '${gitInfo.tag}',
  branch: '${gitInfo.branch}',
  dirty: ${gitInfo.dirty},
  buildDate: '${new Date().toISOString()}'
};

export function getVersionString(): string {
  const parts = [VERSION_INFO.tag];

  // Only show hash for dev builds, not release builds
  if (VERSION_INFO.hash !== 'unknown' && VERSION_INFO.hash !== 'release') {
    parts.push(\`(\${VERSION_INFO.hash}\${VERSION_INFO.dirty ? '-dirty' : ''})\`);
  }

  return parts.join(' ');
}
`;

  writeFileSync(outputPath, content, 'utf-8');
  console.log(`âœ“ Generated version info: ${gitInfo.tag} (${gitInfo.hash}${gitInfo.dirty ? '-dirty' : ''})`);
}

generateVersionFile();
